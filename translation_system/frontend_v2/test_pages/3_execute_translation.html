<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>翻译执行测试 - Translation System</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #ff6b6b;
            padding-bottom: 10px;
        }
        .config {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input, select, button, textarea {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }
        textarea {
            min-height: 100px;
            font-family: monospace;
        }
        button {
            background: #ff6b6b;
            color: white;
            cursor: pointer;
            font-weight: bold;
            width: auto;
            padding: 10px 20px;
            margin-right: 10px;
        }
        button:hover {
            background: #ff5252;
        }
        button.secondary {
            background: #6c757d;
        }
        button.secondary:hover {
            background: #5a6268;
        }
        button.warning {
            background: #ffc107;
            color: #333;
        }
        button.warning:hover {
            background: #e0a800;
        }
        .response {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
        }
        .status {
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
            font-weight: bold;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        .status.warning {
            background: #fff3cd;
            color: #856404;
        }
        .status.running {
            background: #cfe2ff;
            color: #084298;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745 0%, #20c997 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b6b;
        }
        .stat-label {
            color: #666;
            font-size: 14px;
        }
        .llm-config {
            background: #fff3cd;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <h1>🚀 翻译执行测试 (Execute Translation)</h1>

    <div class="container">
        <h2>配置</h2>
        <div class="config">
            <div class="form-group">
                <label>后端地址：</label>
                <input type="text" id="apiUrl" value="http://localhost:8013" />
            </div>
        </div>
    </div>

    <div class="container">
        <h2>1. LLM配置</h2>
        <div class="llm-config">
            <div class="form-group">
                <label>LLM Provider（使用配置文件中的provider）：</label>
                <select id="llmProvider">
                    <option value="">使用默认配置</option>
                    <option value="openai">OpenAI</option>
                    <option value="gpt-5-nano">GPT-5 Nano</option>
                    <option value="qwen">Qwen</option>
                    <option value="qwen-plus">Qwen Plus</option>
                </select>
            </div>
            <div class="info-box" style="background: #fff3cd; border-left-color: #ffc107;">
                <strong>注意：</strong>LLM配置需要在后端 config.yaml 中预先设置，包括 API Key、Model、Base URL 等。
                前端只能选择已配置的 provider。
            </div>
        </div>
    </div>

    <div class="container">
        <h2>2. 开始翻译</h2>
        <form id="startForm">
            <div class="form-group">
                <label>Session ID：</label>
                <input type="text" id="sessionId" placeholder="从任务拆解页面获取的Session ID" required />
            </div>
            <div class="form-group">
                <label>最大并发数：</label>
                <input type="number" id="maxConcurrent" value="5" min="1" max="20" />
            </div>
            <button type="submit">开始翻译</button>
        </form>

        <div class="progress-bar" id="progressBar" style="display: none;">
            <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
        </div>

        <div class="stats-grid" id="executionStats" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="statCompleted">0</div>
                <div class="stat-label">已完成</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statPending">0</div>
                <div class="stat-label">待处理</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statFailed">0</div>
                <div class="stat-label">失败</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statProgress">0%</div>
                <div class="stat-label">进度</div>
            </div>
        </div>

        <h3>执行响应：</h3>
        <div class="response" id="startResponse">等待开始...</div>

        <h3>实时状态：</h3>
        <div class="response" id="executionStatus">等待开始...</div>
    </div>

    <div class="container">
        <h2>3. 控制翻译</h2>
        <div class="form-group">
            <label>Session ID：</label>
            <input type="text" id="controlSessionId" placeholder="输入Session ID" />
        </div>
        <div class="button-group">
            <button onclick="pauseTranslation()" class="warning">暂停</button>
            <button onclick="resumeTranslation()" class="secondary">恢复</button>
            <button onclick="stopTranslation()" style="background: #dc3545;">停止</button>
            <button onclick="getStatus()" style="background: #17a2b8;">获取状态</button>
        </div>

        <h3>控制响应：</h3>
        <div class="response" id="controlResponse">等待操作...</div>
    </div>

    <script>
        const apiUrl = () => document.getElementById('apiUrl').value;
        let statusInterval = null;

        // 开始翻译
        document.getElementById('startForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const sessionId = document.getElementById('sessionId').value;
            const provider = document.getElementById('llmProvider').value;
            const maxWorkers = parseInt(document.getElementById('maxConcurrent').value);

            // 准备请求体，符合后端API要求
            const requestBody = {
                session_id: sessionId
            };

            // 只有选择了非默认provider时才添加
            if (provider) {
                requestBody.provider = provider;
            }

            // 添加max_workers参数
            if (maxWorkers && maxWorkers > 0) {
                requestBody.max_workers = maxWorkers;
            }

            try {
                const response = await fetch(`${apiUrl()}/api/execute/start`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (response.ok) {
                    document.getElementById('startResponse').innerHTML =
                        `<span class="status success">翻译已开始!</span>\n\n${JSON.stringify(data, null, 2)}`;

                    // 显示进度条
                    document.getElementById('progressBar').style.display = 'block';
                    document.getElementById('executionStats').style.display = 'grid';

                    // 自动填充控制表单
                    document.getElementById('controlSessionId').value = sessionId;

                    // 开始定期更新状态
                    startStatusPolling(sessionId);
                } else {
                    document.getElementById('startResponse').innerHTML =
                        `<span class="status error">启动失败!</span>\n\n${JSON.stringify(data, null, 2)}`;
                }
            } catch (error) {
                document.getElementById('startResponse').innerHTML =
                    `<span class="status error">请求错误!</span>\n\n${error.message}`;
            }
        });

        // WebSocket连接对象
        let websocket = null;

        // 开始状态轮询（先启动轮询，WebSocket成功后自动停止轮询）
        function startStatusPolling(sessionId) {
            // 先清除旧的定时器
            if (statusInterval) {
                clearInterval(statusInterval);
            }

            // 立即启动轮询，确保进度显示
            console.log('Starting polling for session:', sessionId);

            // 立即获取一次状态
            updateExecutionStatus(sessionId);

            // 每2秒更新一次
            statusInterval = setInterval(() => {
                updateExecutionStatus(sessionId);
            }, 2000);

            // 尝试WebSocket连接（成功后会自动停止轮询）
            connectWebSocket(sessionId);
        }

        // WebSocket连接函数
        function connectWebSocket(sessionId) {
            try {
                const wsUrl = `ws://localhost:8013/ws/progress/${sessionId}`;
                console.log('Connecting to WebSocket:', wsUrl);

                // 关闭旧连接
                if (websocket) {
                    websocket.close();
                    websocket = null;
                }

                websocket = new WebSocket(wsUrl);

                websocket.onopen = function(event) {
                    console.log('✅ WebSocket connected for session:', sessionId);

                    // WebSocket连接成功，停止轮询
                    if (statusInterval) {
                        clearInterval(statusInterval);
                        statusInterval = null;
                        console.log('Stopped polling - using WebSocket');
                    }

                    // 显示WebSocket状态
                    const statusElement = document.getElementById('executionStatus');
                    if (statusElement && statusElement.innerHTML) {
                        statusElement.innerHTML = '<span style="color: #28a745;">🔌 WebSocket实时连接</span>\n' + statusElement.innerHTML;
                    }

                    // 确保进度条和统计显示
                    document.getElementById('progressBar').style.display = 'block';
                    document.getElementById('executionStats').style.display = 'grid';
                };

                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);

                        if (data.type === 'progress') {
                            updateProgressFromWebSocket(data.data);
                        } else if (data.type === 'ping') {
                            if (websocket.readyState === WebSocket.OPEN) {
                                websocket.send(JSON.stringify({ type: 'pong' }));
                            }
                        }
                    } catch (e) {
                        console.error('WebSocket message parse error:', e);
                    }
                };

                websocket.onerror = function(error) {
                    console.error('❌ WebSocket error:', error);
                    websocket = null;

                    // WebSocket失败，确保轮询继续运行
                    if (!statusInterval) {
                        console.log('WebSocket failed, ensuring polling continues');
                        statusInterval = setInterval(() => {
                            updateExecutionStatus(sessionId);
                        }, 2000);
                    }
                };

                websocket.onclose = function(event) {
                    console.log('WebSocket closed:', event.code, event.reason);
                    websocket = null;

                    // 非正常关闭且任务未完成时，确保轮询运行
                    if (event.code !== 1000 && !isTaskCompleted()) {
                        if (!statusInterval) {
                            console.log('WebSocket closed unexpectedly, restarting polling');
                            updateExecutionStatus(sessionId);
                            statusInterval = setInterval(() => {
                                updateExecutionStatus(sessionId);
                            }, 2000);
                        }
                    }
                };

            } catch (error) {
                console.error('Failed to connect WebSocket:', error);
                websocket = null;
                // 连接失败时轮询已经在运行，无需额外处理
            }
        }

        // 从WebSocket更新进度
        function updateProgressFromWebSocket(progressData) {
            const { total, completed, processing, pending, failed, completion_rate } = progressData;

            // 使用completion_rate如果提供，否则计算
            const progressPercent = completion_rate !== undefined
                ? completion_rate
                : (total > 0 ? (completed / total * 100) : 0);

            // 更新进度条
            document.getElementById('progressFill').style.width = progressPercent + '%';
            document.getElementById('progressFill').textContent = progressPercent.toFixed(1) + '%';

            // 更新统计卡片
            document.getElementById('statCompleted').textContent = completed || 0;
            document.getElementById('statPending').textContent = pending || 0;
            document.getElementById('statFailed').textContent = failed || 0;
            document.getElementById('statProgress').textContent = (completion_rate || 0).toFixed(1) + '%';

            // 更新状态显示
            const statusDiv = document.getElementById('executionStatus');
            if (statusDiv) {
                let statusHtml = '<span style="color: #28a745;">🔌 WebSocket实时更新</span>\n';
                statusHtml += `<span class="status running">执行中...</span>\n\n`;
                statusHtml += `📊 进度: ${completed}/${total} (${(completion_rate || 0).toFixed(1)}%)\n`;
                statusHtml += `✅ 已完成: ${completed}\n`;
                statusHtml += `⚡ 处理中: ${processing}\n`;
                statusHtml += `⏳ 待处理: ${pending}\n`;
                statusHtml += `❌ 失败: ${failed}`;
                statusDiv.innerHTML = statusHtml;

                // 任务完成时关闭WebSocket
                if (completed === total && total > 0) {
                    if (websocket) {
                        websocket.close(1000, 'Completed');
                    }
                    if (statusInterval) {
                        clearInterval(statusInterval);
                    }
                    statusDiv.innerHTML = `<span class="status success">✅ 翻译完成!</span>\n\n已完成 ${completed}/${total} 个任务`;
                }
            }
        }

        // 检查任务是否完成
        function isTaskCompleted() {
            const progressText = document.getElementById('statProgress')?.textContent;
            return progressText && parseFloat(progressText) >= 100;
        }

        // 更新执行状态（轮询方式）
        async function updateExecutionStatus(sessionId) {
            try {
                const response = await fetch(`${apiUrl()}/api/execute/status/${sessionId}`);
                const data = await response.json();

                console.log('Polling status update:', data);

                if (response.ok) {
                    // 确保进度条和统计面板显示
                    document.getElementById('progressBar').style.display = 'block';
                    document.getElementById('executionStats').style.display = 'grid';

                    const progress = data.completion_rate || 0;

                    // 更新进度条
                    document.getElementById('progressFill').style.width = `${progress}%`;
                    document.getElementById('progressFill').textContent = `${progress.toFixed(1)}%`;

                    // 更新统计 - 兼容不同的数据结构
                    const progressData = data.progress || data;
                    document.getElementById('statCompleted').textContent = progressData.completed || 0;
                    document.getElementById('statPending').textContent = progressData.pending || 0;
                    document.getElementById('statFailed').textContent = progressData.failed || 0;
                    document.getElementById('statProgress').textContent = `${progress.toFixed(1)}%`;

                    // 更新执行状态显示
                    const statusDiv = document.getElementById('executionStatus');
                    if (statusDiv) {
                        let statusHtml = `<span class="status running">执行中...</span>\n\n`;
                        statusHtml += `📊 进度: ${progressData.completed || 0}/${progressData.total || 0} (${progress.toFixed(1)}%)\n`;
                        statusHtml += `✅ 已完成: ${progressData.completed || 0}\n`;
                        statusHtml += `⚡ 处理中: ${progressData.processing || 0}\n`;
                        statusHtml += `⏳ 待处理: ${progressData.pending || 0}\n`;
                        statusHtml += `❌ 失败: ${progressData.failed || 0}`;
                        statusDiv.innerHTML = statusHtml;
                    }

                    // 如果完成或停止，停止轮询
                    if (data.status === 'completed' || data.status === 'stopped' || progress >= 100) {
                        clearInterval(statusInterval);
                        statusInterval = null;
                        console.log('Task completed, stopped polling');

                        if (statusDiv) {
                            statusDiv.innerHTML = `<span class="status success">✅ 翻译完成!</span>\n\n已完成 ${progressData.completed || 0}/${progressData.total || 0} 个任务`;
                        }
                    }
                } else {
                    console.error('Status API returned error:', data);
                }
            } catch (error) {
                console.error('状态更新失败:', error);
            }
        }

        // 暂停翻译
        async function pauseTranslation() {
            const sessionId = document.getElementById('controlSessionId').value;
            if (!sessionId) {
                alert('请输入Session ID');
                return;
            }

            try {
                const response = await fetch(`${apiUrl()}/api/execute/pause/${sessionId}`, {
                    method: 'POST'
                });
                const data = await response.json();

                document.getElementById('controlResponse').innerHTML = response.ok ?
                    `<span class="status warning">已暂停!</span>\n\n${JSON.stringify(data, null, 2)}` :
                    `<span class="status error">暂停失败!</span>\n\n${JSON.stringify(data, null, 2)}`;
            } catch (error) {
                document.getElementById('controlResponse').innerHTML =
                    `<span class="status error">请求错误!</span>\n\n${error.message}`;
            }
        }

        // 恢复翻译
        async function resumeTranslation() {
            const sessionId = document.getElementById('controlSessionId').value;
            if (!sessionId) {
                alert('请输入Session ID');
                return;
            }

            try {
                const response = await fetch(`${apiUrl()}/api/execute/resume/${sessionId}`, {
                    method: 'POST'
                });
                const data = await response.json();

                document.getElementById('controlResponse').innerHTML = response.ok ?
                    `<span class="status success">已恢复!</span>\n\n${JSON.stringify(data, null, 2)}` :
                    `<span class="status error">恢复失败!</span>\n\n${JSON.stringify(data, null, 2)}`;

                if (response.ok) {
                    startStatusPolling(sessionId);
                }
            } catch (error) {
                document.getElementById('controlResponse').innerHTML =
                    `<span class="status error">请求错误!</span>\n\n${error.message}`;
            }
        }

        // 停止翻译
        async function stopTranslation() {
            const sessionId = document.getElementById('controlSessionId').value;
            if (!sessionId) {
                alert('请输入Session ID');
                return;
            }

            if (!confirm('确定要停止翻译吗？')) {
                return;
            }

            try {
                const response = await fetch(`${apiUrl()}/api/execute/stop/${sessionId}`, {
                    method: 'POST'
                });
                const data = await response.json();

                document.getElementById('controlResponse').innerHTML = response.ok ?
                    `<span class="status error">已停止!</span>\n\n${JSON.stringify(data, null, 2)}` :
                    `<span class="status error">停止失败!</span>\n\n${JSON.stringify(data, null, 2)}`;

                if (response.ok && statusInterval) {
                    clearInterval(statusInterval);
                    statusInterval = null;
                }
            } catch (error) {
                document.getElementById('controlResponse').innerHTML =
                    `<span class="status error">请求错误!</span>\n\n${error.message}`;
            }
        }

        // 获取状态
        async function getStatus() {
            const sessionId = document.getElementById('controlSessionId').value;
            if (!sessionId) {
                alert('请输入Session ID');
                return;
            }

            try {
                const response = await fetch(`${apiUrl()}/api/execute/status/${sessionId}`);
                const data = await response.json();

                document.getElementById('controlResponse').innerHTML = response.ok ?
                    `<span class="status running">状态更新!</span>\n\n${JSON.stringify(data, null, 2)}` :
                    `<span class="status error">查询失败!</span>\n\n${JSON.stringify(data, null, 2)}`;

                if (response.ok) {
                    updateExecutionStatus(sessionId);
                }
            } catch (error) {
                document.getElementById('controlResponse').innerHTML =
                    `<span class="status error">请求错误!</span>\n\n${error.message}`;
            }
        }

        // 页面卸载时清理
        window.addEventListener('beforeunload', () => {
            if (statusInterval) {
                clearInterval(statusInterval);
            }
        });
    </script>
</body>
</html>