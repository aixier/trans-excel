# 基于批注和颜色的精细翻译方案

## 功能需求

### 1. 批注信息集成
- 将单元格批注作为翻译上下文传递给LLM
- 批注可能包含：翻译要求、术语解释、字数限制、语气要求等

### 2. 基于颜色的翻译任务识别
- **黄色背景（#FFFF00）**：标记为新的源语言，需要翻译到其他列
- **蓝色背景（#0000FF 或其他蓝色）**：标记需要缩短的内容，重新翻译

### 3. 三阶段翻译流程
1. **阶段一：常规空白单元格填充**（现有逻辑）
2. **阶段二：黄色单元格触发的翻译**（新增）
3. **阶段三：蓝色单元格的内容优化**（新增）

## 需要修改的文件

### 1. `/translation_core/translation_engine.py`
**主要修改点：**
- `translate_excel_multi_sheet` 方法：添加三阶段翻译逻辑
- `_detect_color_based_tasks` 新方法：检测基于颜色的翻译任务
- `_process_batch_with_comments` 修改：将批注信息传递给LLM

### 2. `/translation_core/localization_engine.py`
**主要修改点：**
- `create_batch_prompt` 方法：接收并集成批注信息
- 新增参数：`cell_comments`, `translation_hints`

### 3. `/excel_analysis/translation_detector.py`
**主要修改点：**
- `detect_translation_tasks` 方法：扩展以支持颜色检测
- 新增 `detect_color_triggered_tasks` 方法
- 新增 `detect_optimization_tasks` 方法

### 4. `/excel_analysis/enhanced_excel_reader.py`
**主要修改点：**
- `get_cells_by_color` 新方法：按颜色筛选单元格
- `map_comments_to_tasks` 新方法：将批注映射到翻译任务

## 详细实现思路

### 阶段一：空白单元格填充（增强版）

```python
# 伪代码示例
def process_phase_1_blank_cells(df, metadata):
    """阶段一：填充空白单元格，带批注支持"""

    # 1. 检测常规翻译任务（现有逻辑）
    translation_tasks = detect_translation_tasks(df)

    # 2. 为每个任务关联批注信息
    for task in translation_tasks:
        cell_address = f"{col_to_letter(task.source_col)}{task.row+2}"  # +2因为有标题行
        if cell_address in metadata:
            task.comment = metadata[cell_address].comment

    # 3. 批量处理时传递批注
    for batch in batches:
        # 提取批注信息
        batch_comments = {}
        for idx, task in enumerate(batch):
            if task.comment:
                batch_comments[f"text_{idx}"] = task.comment

        # 构建带批注的prompt
        system_prompt = create_batch_prompt(
            texts=[task.source_text for task in batch],
            target_languages=target_languages,
            cell_comments=batch_comments  # 新增参数
        )

        # 调用LLM...
```

### 阶段二：黄色单元格翻译

```python
def process_phase_2_yellow_cells(df, metadata):
    """阶段二：处理黄色单元格作为新源语言"""

    yellow_cells = []

    # 1. 识别所有黄色单元格
    for cell_addr, cell_meta in metadata.items():
        if cell_meta.fill_color and 'FFFF' in cell_meta.fill_color:  # 黄色
            col_letter, row_num = parse_cell_address(cell_addr)
            yellow_cells.append({
                'row': row_num - 2,  # 转换为DataFrame行索引
                'col': letter_to_col(col_letter),
                'value': cell_meta.value,
                'comment': cell_meta.comment
            })

    # 2. 为每个黄色单元格创建翻译任务
    for yellow_cell in yellow_cells:
        row_idx = yellow_cell['row']
        source_text = yellow_cell['value']

        # 找到同一行的其他列作为目标
        for col in df.columns:
            if col != yellow_cell['col'] and is_language_column(col):
                # 创建翻译任务：黄色单元格 → 其他语言列
                task = TranslationTask(
                    row=row_idx,
                    source_col=yellow_cell['col'],
                    target_col=col,
                    source_text=source_text,
                    task_type='yellow_triggered',
                    comment=yellow_cell['comment']
                )
                tasks.append(task)

    # 3. 执行翻译...
```

### 阶段三：蓝色单元格优化

```python
def process_phase_3_blue_cells(df, metadata):
    """阶段三：优化蓝色单元格内容（缩短）"""

    blue_cells = []

    # 1. 识别所有蓝色单元格
    for cell_addr, cell_meta in metadata.items():
        if cell_meta.fill_color and any(blue in cell_meta.fill_color for blue in ['0000FF', '0080FF']):
            blue_cells.append({
                'address': cell_addr,
                'value': cell_meta.value,
                'comment': cell_meta.comment or "请缩短此内容，保持核心意思"
            })

    # 2. 创建优化任务
    for blue_cell in blue_cells:
        # 特殊的prompt用于内容优化
        optimization_prompt = f"""
        请将以下内容缩短至原长度的50-70%，保持核心意思不变：

        原文：{blue_cell['value']}

        要求：
        1. 保留关键信息
        2. 去除冗余表达
        3. 使用更简洁的词汇
        {f"4. 额外说明：{blue_cell['comment']}" if blue_cell['comment'] else ""}
        """

        # 调用LLM进行优化...
        optimized_text = llm.optimize(optimization_prompt)

        # 写回原单元格
        df.at[row, col] = optimized_text
```

## Prompt增强示例

### 带批注的System Prompt

```
你是专业的游戏本地化翻译专家...

特别注意以下单元格的翻译要求：
- text_0: "UI文本，不超过10个字符"
- text_2: "保持友好亲切的语气"
- text_5: "这是技能名称，要保持酷炫感"

翻译任务：
[继续原有格式...]
```

### 黄色单元格触发的翻译Prompt

```
注意：以下文本来自标记为黄色的单元格，表示这是需要特别关注的重要内容。

源文本（来自黄色单元格）：
"终极技能：毁天灭地"

请将此内容翻译为以下语言，确保传达其史诗级的威力感：
- Portuguese (葡萄牙语)
- Thai (泰语)
```

### 蓝色单元格优化Prompt

```
任务类型：内容精简优化

原始文本（标记为蓝色，需要缩短）：
"在这个充满魔法与冒险的奇幻世界中，你将扮演一位勇敢的冒险者，踏上征服黑暗势力的史诗征程。"

优化要求：
1. 缩短至15-20个字
2. 保留"冒险"和"征服"的核心概念
3. 保持史诗感

请提供精简版本...
```

## 实施步骤

### 第一步：增强现有翻译流程
1. 修改 `translation_engine.py`，在批处理中集成批注信息
2. 更新 `localization_engine.py`，在prompt中添加批注内容
3. 测试批注信息是否正确传递给LLM

### 第二步：实现颜色检测
1. 在 `enhanced_excel_reader.py` 中添加颜色筛选方法
2. 创建 `ColorBasedTaskDetector` 类
3. 定义颜色规则配置（可配置化）

### 第三步：实现三阶段翻译
1. 重构 `translate_excel_multi_sheet` 方法
2. 添加阶段控制逻辑
3. 实现阶段间的数据传递

### 第四步：优化和测试
1. 添加日志记录每个阶段的处理情况
2. 创建测试用例覆盖各种场景
3. 性能优化（避免重复处理）

## 配置参数

```python
# 可配置的颜色规则
COLOR_RULES = {
    'source_trigger': {
        'colors': ['#FFFF00', '#FFD700'],  # 黄色系
        'action': 'translate_from_this'
    },
    'optimize_trigger': {
        'colors': ['#0000FF', '#4169E1'],  # 蓝色系
        'action': 'shorten_content'
    },
    'priority_trigger': {
        'colors': ['#FF0000', '#DC143C'],  # 红色系
        'action': 'high_priority'
    }
}

# 优化参数
OPTIMIZATION_CONFIG = {
    'shorten_ratio': 0.6,  # 缩短至原长度的60%
    'preserve_keywords': True,  # 保留关键词
    'maintain_tone': True  # 保持语气
}
```

## 预期效果

1. **更精准的翻译**：批注提供额外上下文，提高翻译质量
2. **灵活的工作流**：通过颜色标记控制翻译流程
3. **内容优化**：自动识别并优化过长的翻译
4. **可视化管理**：颜色直观展示任务类型和优先级

## 注意事项

1. **性能影响**：三阶段处理可能增加处理时间
2. **颜色冲突**：需要定义清晰的颜色优先级规则
3. **批注编码**：确保批注中的特殊字符正确处理
4. **回滚机制**：每个阶段都应该支持独立回滚

## 测试场景

1. **纯空白单元格**：验证阶段一正常工作
2. **带批注的空白单元格**：验证批注正确传递
3. **黄色源 + 空白目标**：验证阶段二触发
4. **蓝色已填充单元格**：验证阶段三优化
5. **混合场景**：三个阶段都有任务
6. **无任务场景**：文件已完全翻译

---

*文档创建时间：2024-09-22*
*作者：翻译系统架构师*